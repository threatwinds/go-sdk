// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package plugins

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// EngineClient is the client API for Engine service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EngineClient interface {
	Input(ctx context.Context, opts ...grpc.CallOption) (Engine_InputClient, error)
	Notify(ctx context.Context, opts ...grpc.CallOption) (Engine_NotifyClient, error)
}

type engineClient struct {
	cc grpc.ClientConnInterface
}

func NewEngineClient(cc grpc.ClientConnInterface) EngineClient {
	return &engineClient{cc}
}

func (c *engineClient) Input(ctx context.Context, opts ...grpc.CallOption) (Engine_InputClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Engine_serviceDesc.Streams[0], "/plugins.Engine/Input", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineInputClient{stream}
	return x, nil
}

type Engine_InputClient interface {
	Send(*Log) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type engineInputClient struct {
	grpc.ClientStream
}

func (x *engineInputClient) Send(m *Log) error {
	return x.ClientStream.SendMsg(m)
}

func (x *engineInputClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *engineClient) Notify(ctx context.Context, opts ...grpc.CallOption) (Engine_NotifyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Engine_serviceDesc.Streams[1], "/plugins.Engine/Notify", opts...)
	if err != nil {
		return nil, err
	}
	x := &engineNotifyClient{stream}
	return x, nil
}

type Engine_NotifyClient interface {
	Send(*Message) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type engineNotifyClient struct {
	grpc.ClientStream
}

func (x *engineNotifyClient) Send(m *Message) error {
	return x.ClientStream.SendMsg(m)
}

func (x *engineNotifyClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EngineServer is the server API for Engine service.
// All implementations must embed UnimplementedEngineServer
// for forward compatibility
type EngineServer interface {
	Input(Engine_InputServer) error
	Notify(Engine_NotifyServer) error
	mustEmbedUnimplementedEngineServer()
}

// UnimplementedEngineServer must be embedded to have forward compatible implementations.
type UnimplementedEngineServer struct {
}

func (UnimplementedEngineServer) Input(Engine_InputServer) error {
	return status.Errorf(codes.Unimplemented, "method Input not implemented")
}
func (UnimplementedEngineServer) Notify(Engine_NotifyServer) error {
	return status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedEngineServer) mustEmbedUnimplementedEngineServer() {}

// UnsafeEngineServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EngineServer will
// result in compilation errors.
type UnsafeEngineServer interface {
	mustEmbedUnimplementedEngineServer()
}

func RegisterEngineServer(s *grpc.Server, srv EngineServer) {
	s.RegisterService(&_Engine_serviceDesc, srv)
}

func _Engine_Input_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Input(&engineInputServer{stream})
}

type Engine_InputServer interface {
	Send(*Ack) error
	Recv() (*Log, error)
	grpc.ServerStream
}

type engineInputServer struct {
	grpc.ServerStream
}

func (x *engineInputServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *engineInputServer) Recv() (*Log, error) {
	m := new(Log)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Engine_Notify_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EngineServer).Notify(&engineNotifyServer{stream})
}

type Engine_NotifyServer interface {
	Send(*Ack) error
	Recv() (*Message, error)
	grpc.ServerStream
}

type engineNotifyServer struct {
	grpc.ServerStream
}

func (x *engineNotifyServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *engineNotifyServer) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Engine_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Engine",
	HandlerType: (*EngineServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Input",
			Handler:       _Engine_Input_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Notify",
			Handler:       _Engine_Notify_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

// ParsingClient is the client API for Parsing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParsingClient interface {
	ParseLog(ctx context.Context, in *Transform, opts ...grpc.CallOption) (*Draft, error)
}

type parsingClient struct {
	cc grpc.ClientConnInterface
}

func NewParsingClient(cc grpc.ClientConnInterface) ParsingClient {
	return &parsingClient{cc}
}

func (c *parsingClient) ParseLog(ctx context.Context, in *Transform, opts ...grpc.CallOption) (*Draft, error) {
	out := new(Draft)
	err := c.cc.Invoke(ctx, "/plugins.Parsing/ParseLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParsingServer is the server API for Parsing service.
// All implementations must embed UnimplementedParsingServer
// for forward compatibility
type ParsingServer interface {
	ParseLog(context.Context, *Transform) (*Draft, error)
	mustEmbedUnimplementedParsingServer()
}

// UnimplementedParsingServer must be embedded to have forward compatible implementations.
type UnimplementedParsingServer struct {
}

func (UnimplementedParsingServer) ParseLog(context.Context, *Transform) (*Draft, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ParseLog not implemented")
}
func (UnimplementedParsingServer) mustEmbedUnimplementedParsingServer() {}

// UnsafeParsingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParsingServer will
// result in compilation errors.
type UnsafeParsingServer interface {
	mustEmbedUnimplementedParsingServer()
}

func RegisterParsingServer(s *grpc.Server, srv ParsingServer) {
	s.RegisterService(&_Parsing_serviceDesc, srv)
}

func _Parsing_ParseLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Transform)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParsingServer).ParseLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Parsing/ParseLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParsingServer).ParseLog(ctx, req.(*Transform))
	}
	return interceptor(ctx, in, info, handler)
}

var _Parsing_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Parsing",
	HandlerType: (*ParsingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ParseLog",
			Handler:    _Parsing_ParseLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

// AnalysisClient is the client API for Analysis service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AnalysisClient interface {
	Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (Analysis_AnalyzeClient, error)
}

type analysisClient struct {
	cc grpc.ClientConnInterface
}

func NewAnalysisClient(cc grpc.ClientConnInterface) AnalysisClient {
	return &analysisClient{cc}
}

func (c *analysisClient) Analyze(ctx context.Context, in *Event, opts ...grpc.CallOption) (Analysis_AnalyzeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Analysis_serviceDesc.Streams[0], "/plugins.Analysis/Analyze", opts...)
	if err != nil {
		return nil, err
	}
	x := &analysisAnalyzeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Analysis_AnalyzeClient interface {
	Recv() (*Alert, error)
	grpc.ClientStream
}

type analysisAnalyzeClient struct {
	grpc.ClientStream
}

func (x *analysisAnalyzeClient) Recv() (*Alert, error) {
	m := new(Alert)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// AnalysisServer is the server API for Analysis service.
// All implementations must embed UnimplementedAnalysisServer
// for forward compatibility
type AnalysisServer interface {
	Analyze(*Event, Analysis_AnalyzeServer) error
	mustEmbedUnimplementedAnalysisServer()
}

// UnimplementedAnalysisServer must be embedded to have forward compatible implementations.
type UnimplementedAnalysisServer struct {
}

func (UnimplementedAnalysisServer) Analyze(*Event, Analysis_AnalyzeServer) error {
	return status.Errorf(codes.Unimplemented, "method Analyze not implemented")
}
func (UnimplementedAnalysisServer) mustEmbedUnimplementedAnalysisServer() {}

// UnsafeAnalysisServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AnalysisServer will
// result in compilation errors.
type UnsafeAnalysisServer interface {
	mustEmbedUnimplementedAnalysisServer()
}

func RegisterAnalysisServer(s *grpc.Server, srv AnalysisServer) {
	s.RegisterService(&_Analysis_serviceDesc, srv)
}

func _Analysis_Analyze_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Event)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AnalysisServer).Analyze(m, &analysisAnalyzeServer{stream})
}

type Analysis_AnalyzeServer interface {
	Send(*Alert) error
	grpc.ServerStream
}

type analysisAnalyzeServer struct {
	grpc.ServerStream
}

func (x *analysisAnalyzeServer) Send(m *Alert) error {
	return x.ServerStream.SendMsg(m)
}

var _Analysis_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Analysis",
	HandlerType: (*AnalysisServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Analyze",
			Handler:       _Analysis_Analyze_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

// CorrelationClient is the client API for Correlation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CorrelationClient interface {
	Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type correlationClient struct {
	cc grpc.ClientConnInterface
}

func NewCorrelationClient(cc grpc.ClientConnInterface) CorrelationClient {
	return &correlationClient{cc}
}

func (c *correlationClient) Correlate(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/plugins.Correlation/Correlate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CorrelationServer is the server API for Correlation service.
// All implementations must embed UnimplementedCorrelationServer
// for forward compatibility
type CorrelationServer interface {
	Correlate(context.Context, *Alert) (*emptypb.Empty, error)
	mustEmbedUnimplementedCorrelationServer()
}

// UnimplementedCorrelationServer must be embedded to have forward compatible implementations.
type UnimplementedCorrelationServer struct {
}

func (UnimplementedCorrelationServer) Correlate(context.Context, *Alert) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Correlate not implemented")
}
func (UnimplementedCorrelationServer) mustEmbedUnimplementedCorrelationServer() {}

// UnsafeCorrelationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CorrelationServer will
// result in compilation errors.
type UnsafeCorrelationServer interface {
	mustEmbedUnimplementedCorrelationServer()
}

func RegisterCorrelationServer(s *grpc.Server, srv CorrelationServer) {
	s.RegisterService(&_Correlation_serviceDesc, srv)
}

func _Correlation_Correlate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CorrelationServer).Correlate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Correlation/Correlate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CorrelationServer).Correlate(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

var _Correlation_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Correlation",
	HandlerType: (*CorrelationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Correlate",
			Handler:    _Correlation_Correlate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

// NotificationClient is the client API for Notification service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NotificationClient interface {
	Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type notificationClient struct {
	cc grpc.ClientConnInterface
}

func NewNotificationClient(cc grpc.ClientConnInterface) NotificationClient {
	return &notificationClient{cc}
}

func (c *notificationClient) Notify(ctx context.Context, in *Message, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/plugins.Notification/Notify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NotificationServer is the server API for Notification service.
// All implementations must embed UnimplementedNotificationServer
// for forward compatibility
type NotificationServer interface {
	Notify(context.Context, *Message) (*emptypb.Empty, error)
	mustEmbedUnimplementedNotificationServer()
}

// UnimplementedNotificationServer must be embedded to have forward compatible implementations.
type UnimplementedNotificationServer struct {
}

func (UnimplementedNotificationServer) Notify(context.Context, *Message) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Notify not implemented")
}
func (UnimplementedNotificationServer) mustEmbedUnimplementedNotificationServer() {}

// UnsafeNotificationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NotificationServer will
// result in compilation errors.
type UnsafeNotificationServer interface {
	mustEmbedUnimplementedNotificationServer()
}

func RegisterNotificationServer(s *grpc.Server, srv NotificationServer) {
	s.RegisterService(&_Notification_serviceDesc, srv)
}

func _Notification_Notify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NotificationServer).Notify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Notification/Notify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NotificationServer).Notify(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

var _Notification_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Notification",
	HandlerType: (*NotificationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Notify",
			Handler:    _Notification_Notify_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}

// IntegrationClient is the client API for Integration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntegrationClient interface {
	ProcessLog(ctx context.Context, opts ...grpc.CallOption) (Integration_ProcessLogClient, error)
}

type integrationClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegrationClient(cc grpc.ClientConnInterface) IntegrationClient {
	return &integrationClient{cc}
}

func (c *integrationClient) ProcessLog(ctx context.Context, opts ...grpc.CallOption) (Integration_ProcessLogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Integration_serviceDesc.Streams[0], "/plugins.Integration/ProcessLog", opts...)
	if err != nil {
		return nil, err
	}
	x := &integrationProcessLogClient{stream}
	return x, nil
}

type Integration_ProcessLogClient interface {
	Send(*Log) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type integrationProcessLogClient struct {
	grpc.ClientStream
}

func (x *integrationProcessLogClient) Send(m *Log) error {
	return x.ClientStream.SendMsg(m)
}

func (x *integrationProcessLogClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// IntegrationServer is the server API for Integration service.
// All implementations must embed UnimplementedIntegrationServer
// for forward compatibility
type IntegrationServer interface {
	ProcessLog(Integration_ProcessLogServer) error
	mustEmbedUnimplementedIntegrationServer()
}

// UnimplementedIntegrationServer must be embedded to have forward compatible implementations.
type UnimplementedIntegrationServer struct {
}

func (UnimplementedIntegrationServer) ProcessLog(Integration_ProcessLogServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessLog not implemented")
}
func (UnimplementedIntegrationServer) mustEmbedUnimplementedIntegrationServer() {}

// UnsafeIntegrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntegrationServer will
// result in compilation errors.
type UnsafeIntegrationServer interface {
	mustEmbedUnimplementedIntegrationServer()
}

func RegisterIntegrationServer(s *grpc.Server, srv IntegrationServer) {
	s.RegisterService(&_Integration_serviceDesc, srv)
}

func _Integration_ProcessLog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IntegrationServer).ProcessLog(&integrationProcessLogServer{stream})
}

type Integration_ProcessLogServer interface {
	Send(*Ack) error
	Recv() (*Log, error)
	grpc.ServerStream
}

type integrationProcessLogServer struct {
	grpc.ServerStream
}

func (x *integrationProcessLogServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *integrationProcessLogServer) Recv() (*Log, error) {
	m := new(Log)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Integration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Integration",
	HandlerType: (*IntegrationServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProcessLog",
			Handler:       _Integration_ProcessLog_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "plugins.proto",
}

// OutputClient is the client API for Output service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OutputClient interface {
	EventOutput(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AlertOutput(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type outputClient struct {
	cc grpc.ClientConnInterface
}

func NewOutputClient(cc grpc.ClientConnInterface) OutputClient {
	return &outputClient{cc}
}

func (c *outputClient) EventOutput(ctx context.Context, in *Event, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/plugins.Output/EventOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *outputClient) AlertOutput(ctx context.Context, in *Alert, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/plugins.Output/AlertOutput", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OutputServer is the server API for Output service.
// All implementations must embed UnimplementedOutputServer
// for forward compatibility
type OutputServer interface {
	EventOutput(context.Context, *Event) (*emptypb.Empty, error)
	AlertOutput(context.Context, *Alert) (*emptypb.Empty, error)
	mustEmbedUnimplementedOutputServer()
}

// UnimplementedOutputServer must be embedded to have forward compatible implementations.
type UnimplementedOutputServer struct {
}

func (UnimplementedOutputServer) EventOutput(context.Context, *Event) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventOutput not implemented")
}
func (UnimplementedOutputServer) AlertOutput(context.Context, *Alert) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlertOutput not implemented")
}
func (UnimplementedOutputServer) mustEmbedUnimplementedOutputServer() {}

// UnsafeOutputServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OutputServer will
// result in compilation errors.
type UnsafeOutputServer interface {
	mustEmbedUnimplementedOutputServer()
}

func RegisterOutputServer(s *grpc.Server, srv OutputServer) {
	s.RegisterService(&_Output_serviceDesc, srv)
}

func _Output_EventOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServer).EventOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Output/EventOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServer).EventOutput(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _Output_AlertOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Alert)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OutputServer).AlertOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/plugins.Output/AlertOutput",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OutputServer).AlertOutput(ctx, req.(*Alert))
	}
	return interceptor(ctx, in, info, handler)
}

var _Output_serviceDesc = grpc.ServiceDesc{
	ServiceName: "plugins.Output",
	HandlerType: (*OutputServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EventOutput",
			Handler:    _Output_EventOutput_Handler,
		},
		{
			MethodName: "AlertOutput",
			Handler:    _Output_AlertOutput_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "plugins.proto",
}
